// Copyright 2016 Google, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////

package com.firebase.jobdispatcher;

import static com.firebase.jobdispatcher.GooglePlayReceiver.getJobCoder;
import static java.util.concurrent.TimeUnit.MILLISECONDS;
import static java.util.concurrent.TimeUnit.SECONDS;

import android.app.Service;
import android.content.Intent;
import android.content.res.Configuration;
import android.os.Binder;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.os.RemoteException;
import android.os.SystemClock;
import android.support.annotation.AnyThread;
import android.support.annotation.BinderThread;
import android.os.RemoteException;
// import android.support.annotation.GuardedBy;
import android.support.annotation.IntDef;
import android.support.annotation.MainThread;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.VisibleForTesting;
import android.support.annotation.WorkerThread;
import android.support.v4.util.SimpleArrayMap;
import android.text.format.DateUtils;
import android.util.Log;
import java.io.FileDescriptor;
import java.io.PrintWriter;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.Locale;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import org.json.JSONObject;

/**
 * JobService is the fundamental unit of work used in the JobDispatcher.
 *
 * <p>Users will need to override {@link #onStartJob(JobParameters)}, which is where any
 * asynchronous execution should start. This method, like most lifecycle methods, runs on the main
 * thread; you <b>must</b> offload execution to another thread (or {@link android.os.AsyncTask}, or
 * {@link android.os.Handler}, or your favorite flavor of concurrency).
 *
 * <p>Once any asynchronous work is complete {@link #jobFinished(JobParameters, boolean)} should be
 * called to inform the backing driver of the result.
 *
 * <p>Implementations should also override {@link #onStopJob(JobParameters)}, which will be called
 * if the scheduling engine wishes to interrupt your work (most likely because the runtime
 * constraints that are associated with the job in question are no longer met).
 */
public abstract class JobService extends Service {

  /**
   * Returned to indicate the job was executed successfully. If the job is not recurring (i.e. a
   * one-off) it will be dequeued and forgotten. If it is recurring the trigger will be reset and
   * the job will be requeued.
   */
  public static final int RESULT_SUCCESS = 0;

  /**
   * Returned to indicate the job encountered an error during execution and should be retried after
   * a backoff period.
   */
  public static final int RESULT_FAIL_RETRY = 1;

  /**
   * Returned to indicate the job encountered an error during execution but should not be retried.
   * If the job is not recurring (i.e. a one-off) it will be dequeued and forgotten. If it is
   * recurring the trigger will be reset and the job will be requeued.
   */
  public static final int RESULT_FAIL_NORETRY = 2;

  /** The result returned from a job execution. */
  @Retention(RetentionPolicy.SOURCE)
  @IntDef({RESULT_SUCCESS, RESULT_FAIL_RETRY, RESULT_FAIL_NORETRY})
  public @interface JobResult {}

  static final String TAG = "FJD.JobService";

  @VisibleForTesting
  static final String ACTION_EXECUTE = "com.firebase.jobdispatcher.ACTION_EXECUTE";

  private static final Handler mainHandler = new Handler(Looper.getMainLooper());

  /** A background executor that lazily creates up to one thread. */
  @VisibleForTesting
  final ExecutorService backgroundExecutor =
      new ThreadPoolExecutor(
          /* corePoolSize= */ 0,
          /* maximumPoolSize= */ 1,
          /* keepAliveTime= */ 60L,
          /* unit= */ SECONDS,
          /* workQueue= */ new LinkedBlockingQueue<Runnable>());

  /**
   * Correlates job tags (unique strings) with Messages, which are used to signal the completion of
   * a job.
   *
   * <p>All access should happen on the {@link #backgroundExecutor}.
   */
  // @GuardedBy("runningJobs")
  private final SimpleArrayMap<Stri